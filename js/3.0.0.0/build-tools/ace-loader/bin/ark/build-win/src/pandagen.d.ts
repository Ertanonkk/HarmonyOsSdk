/**
 * Imlementation of bytecode generator.
 * The PandaGen works with IR and provides an API
 * to the compiler.
 *
 * This file should not contain imports of TypeScipt's AST nodes.
 */
import * as ts from "typescript";
import { BinaryOperator, PrefixUnaryOperator, SyntaxKind } from "typescript";
import { LiteralBuffer } from "./base/literal";
import { VregisterCache } from "./base/vregisterCache";
import { NodeKind, VariableDebugInfo } from "./debuginfo";
import { IRNode, Label, VReg } from "./irnodes";
import { LoopScope, Scope, VariableScope } from "./scope";
import { CatchTable } from "./statement/tryStatement";
import { Variable } from "./variable";
export declare class PandaGen {
    private debugTag;
    readonly internalName: string;
    private parametersCount;
    private locals;
    private temps;
    private insns;
    private scope;
    private vregisterCache;
    private catchMap;
    private totalRegsNum;
    private variableDebugInfoArray;
    private firstStmt;
    private sourceFileDebugInfo;
    private sourceCodeDebugInfo;
    private icSize;
    private static literalArrayBuffer;
    constructor(internalName: string, parametersCount: number, scope?: Scope | undefined);
    getSourceCodeDebugInfo(): string | undefined;
    setSourceCodeDebugInfo(code: string): void;
    getSourceFileDebugInfo(): string;
    setSourceFileDebugInfo(sourceFile: string): void;
    static getLiteralArrayBuffer(): LiteralBuffer[];
    static clearLiteralArrayBuffer(): void;
    getParameterLength(): number | undefined;
    getFuncName(): string;
    getICSize(): number;
    setICSize(total: number): void;
    getFirstStmt(): ts.Statement | undefined;
    setFirstStmt(firstStmt: ts.Statement): void;
    getVregisterCache(): VregisterCache;
    getCatchMap(): Map<Label, CatchTable>;
    getScope(): Scope | undefined;
    getVariableDebugInfoArray(): VariableDebugInfo[];
    addDebugVariableInfo(variable: VariableDebugInfo): void;
    allocLocalVreg(): VReg;
    getVregForVariable(v: Variable): VReg;
    getTemp(): VReg;
    freeTemps(...temps: VReg[]): void;
    getInsns(): IRNode[];
    printInsns(): void;
    setTotalRegsNum(num: number): void;
    getTotalRegsNum(): number;
    getParametersCount(): number;
    getLocals(): VReg[];
    getTemps(): VReg[];
    storeAccumulator(node: ts.Node | NodeKind, vreg: VReg): void;
    loadAccFromArgs(node: ts.Node): void;
    deleteObjProperty(node: ts.Node, obj: VReg, prop: VReg): void;
    loadAccumulator(node: ts.Node | NodeKind, vreg: VReg): void;
    createLexEnv(node: ts.Node, env: VReg, scope: VariableScope | LoopScope): void;
    popLexicalEnv(node: ts.Node): void;
    loadAccFromLexEnv(node: ts.Node, scope: Scope, level: number, v: Variable): void;
    storeAccToLexEnv(node: ts.Node | NodeKind, scope: Scope, level: number, v: Variable, isDeclaration: boolean): void;
    loadObjProperty(node: ts.Node, obj: VReg, prop: VReg | string | number): void;
    storeObjProperty(node: ts.Node | NodeKind, obj: VReg, prop: VReg | string | number): void;
    storeOwnProperty(node: ts.Node | NodeKind, obj: VReg, prop: VReg | string | number, nameSetting?: boolean): void;
    private loadObjByName;
    private storeObjByName;
    private loadObjByIndex;
    private storeObjByIndex;
    private loadObjByValue;
    private storeObjByValue;
    private stOwnByName;
    private stOwnByIndex;
    private stOwnByValue;
    tryLoadGlobalByName(node: ts.Node, string_id: string): void;
    tryStoreGlobalByName(node: ts.Node, string_id: string): void;
    loadGlobalVar(node: ts.Node, string_id: string): void;
    storeGlobalVar(node: ts.Node | NodeKind, string_id: string): void;
    loadAccumulatorString(node: ts.Node | NodeKind, str: string): void;
    loadAccumulatorFloat(node: ts.Node, num: number): void;
    loadAccumulatorInt(node: ts.Node, num: number): void;
    moveVreg(node: ts.Node | NodeKind, vd: VReg, vs: VReg): void;
    label(node: ts.Node, label: Label): void;
    branch(node: ts.Node | NodeKind, target: Label): void;
    isTrue(node: ts.Node): void;
    jumpIfTrue(node: ts.Node, target: Label): void;
    isFalse(node: ts.Node): void;
    jumpIfFalse(node: ts.Node, target: Label): void;
    debugger(node: ts.Node): void;
    throwUndefinedIfHole(node: ts.Node, hole: VReg, name: VReg): void;
    /**
     * The method generates code for ther following cases
     *          if (lhs OP acc) {...}
     * ifFalse: ...
     */
    condition(node: ts.Node, op: SyntaxKind, lhs: VReg, ifFalse: Label): void;
    unary(node: ts.Node, op: PrefixUnaryOperator, operand: VReg): void;
    binary(node: ts.Node, op: BinaryOperator, lhs: VReg): void;
    throw(node: ts.Node): void;
    throwThrowNotExist(node: ts.Node): void;
    throwDeleteSuperProperty(node: ts.Node): void;
    return(node: ts.Node | NodeKind): void;
    call(node: ts.Node, args: VReg[], passThis: boolean): void;
    returnUndefined(node: ts.Node | NodeKind): void;
    newObject(node: ts.Node, args: VReg[]): void;
    defineMethod(node: ts.FunctionLikeDeclaration, name: string, objReg: VReg, env: VReg): void;
    defineFunction(node: ts.FunctionLikeDeclaration | NodeKind, realNode: ts.FunctionLikeDeclaration, name: string, env: VReg): void;
    typeOf(node: ts.Node): void;
    callSpread(node: ts.Node, func: VReg, thisReg: VReg, args: VReg): void;
    newObjSpread(node: ts.Node, obj: VReg, target: VReg): void;
    getUnmappedArgs(node: ts.Node): void;
    toNumber(node: ts.Node, arg: VReg): void;
    createGeneratorObj(node: ts.Node, funcObj: VReg): void;
    EcmaCreateiterresultobj(node: ts.Node, value: VReg, done: VReg): void;
    suspendGenerator(node: ts.Node, genObj: VReg, iterRslt: VReg): void;
    resumeGenerator(node: ts.Node, genObj: VReg): void;
    getResumeMode(node: ts.Node, genObj: VReg): void;
    asyncFunctionEnter(node: ts.Node): void;
    asyncFunctionAwaitUncaught(node: ts.Node, asynFuncObj: VReg, value: VReg): void;
    asyncFunctionResolve(node: ts.Node | NodeKind, asyncObj: VReg, value: VReg, canSuspend: VReg): void;
    asyncFunctionReject(node: ts.Node | NodeKind, asyncObj: VReg, value: VReg, canSuspend: VReg): void;
    getTemplateObject(node: ts.Node | NodeKind, value: VReg): void;
    copyRestArgs(node: ts.Node, index: number): void;
    getPropIterator(node: ts.Node): void;
    getNextPropName(node: ts.Node, iter: VReg): void;
    createEmptyObject(node: ts.Node): void;
    createObjectHavingMethod(node: ts.Node, idx: number, env: VReg): void;
    createObjectWithBuffer(node: ts.Node, idx: number): void;
    setObjectWithProto(node: ts.Node, proto: VReg, object: VReg): void;
    copyDataProperties(node: ts.Node, dstObj: VReg, srcObj: VReg): void;
    defineGetterSetterByValue(node: ts.Node, obj: VReg, name: VReg, getter: VReg, setter: VReg, isComputedPropertyName: boolean): void;
    createEmptyArray(node: ts.Node): void;
    createArrayWithBuffer(node: ts.Node, idx: number): void;
    storeArraySpreadElement(node: ts.Node, array: VReg, index: VReg): void;
    storeLexicalVar(node: ts.Node, level: number, slot: number, value: VReg): void;
    loadLexicalVar(node: ts.Node, level: number, slot: number): void;
    importModule(node: ts.Node, moduleName: string): void;
    loadModuleVariable(node: ts.Node, module: VReg, varName: string): void;
    storeModuleVar(node: ts.Node, moduleVarName: string): void;
    copyModule(node: ts.Node, module: VReg): void;
    defineClassWithBuffer(node: ts.Node, name: string, idx: number, parameterLength: number, base: VReg): void;
    createObjectWithExcludedKeys(node: ts.Node, obj: VReg, args: VReg[]): void;
    throwObjectNonCoercible(node: ts.Node): void;
    getIterator(node: ts.Node): void;
    getIteratorNext(node: ts.Node, iter: VReg, nextMethod: VReg): void;
    closeIterator(node: ts.Node, iter: VReg): void;
    throwIfNotObject(node: ts.Node, obj: VReg): void;
    superCall(node: ts.Node, num: number, start: VReg): void;
    superCallSpread(node: ts.Node, vs: VReg): void;
    ldSuperByName(node: ts.Node, obj: VReg, key: string): void;
    stSuperByName(node: ts.Node, obj: VReg, key: string): void;
    ldSuperByValue(node: ts.Node, obj: VReg, prop: VReg): void;
    stSuperByValue(node: ts.Node, obj: VReg, prop: VReg): void;
    loadSuperProperty(node: ts.Node, obj: VReg, prop: VReg | string | number): void;
    throwIfSuperNotCorrectCall(node: ts.Node, num: number): void;
    storeSuperProperty(node: ts.Node, obj: VReg, prop: VReg | string | number): void;
    loadHomeObject(node: ts.Node): void;
    createRegExpWithLiteral(node: ts.Node, pattern: string, flags: number): void;
    stLetToGlobalRecord(node: ts.Node, string_id: string): void;
    stConstToGlobalRecord(node: ts.Node, string_id: string): void;
    stClassToGlobalRecord(node: ts.Node, string_id: string): void;
    private binaryRelation;
    private add;
}
//# sourceMappingURL=pandagen.d.ts.map