"use strict";
// Huawei Technologies Co.,Ltd.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
exports.__esModule = true;
exports.BuiltinExpander = exports.builtinsCodeMap = void 0;
// Autogenerated file -- DO NOT EDIT!
var ir = __importStar(require("./irnodes"));
exports.builtinsCodeMap = {
    "builtin.acc": {
        "i32tof32": 0,
        0: "i32tof32",
        "i64tof32": 1,
        1: "i64tof32",
        "f64tof32": 2,
        2: "f64tof32",
        "monitorenter": 3,
        3: "monitorenter",
        "monitorexit": 4,
        4: "monitorexit",
        "ldnan": 5,
        5: "ldnan",
        "ldinfinity": 6,
        6: "ldinfinity",
        "ldglobalthis": 7,
        7: "ldglobalthis",
        "ldundefined": 8,
        8: "ldundefined",
        "ldnull": 9,
        9: "ldnull",
        "ldsymbol": 10,
        10: "ldsymbol",
        "ldglobal": 11,
        11: "ldglobal",
        "ldtrue": 12,
        12: "ldtrue",
        "ldfalse": 13,
        13: "ldfalse",
        "throwDyn": 14,
        14: "throwDyn",
        "typeofDyn": 15,
        15: "typeofDyn",
        "getUnmappedArgs": 16,
        16: "getUnmappedArgs",
        "toboolean": 17,
        17: "toboolean",
        "getPropIterator": 18,
        18: "getPropIterator",
        "asyncFunctionEnter": 19,
        19: "asyncFunctionEnter",
        "ldHole": 20,
        20: "ldHole",
        "ReturnUndefined": 21,
        21: "ReturnUndefined",
        "createemptyobject": 22,
        22: "createemptyobject",
        "createemptyarray": 23,
        23: "createemptyarray",
        "GetIterator": 24,
        24: "GetIterator",
        "ThrowThrowNotExists": 25,
        25: "ThrowThrowNotExists",
        "ThrowPatternNonCoercible": 26,
        26: "ThrowPatternNonCoercible",
        "LdHomeObject": 27,
        27: "LdHomeObject"
    },
    "builtin.bin2": {
        "fadd2f32": 0,
        0: "fadd2f32",
        "fsub2f32": 1,
        1: "fsub2f32",
        "fmul2f32": 2,
        2: "fmul2f32",
        "fdiv2f32": 3,
        3: "fdiv2f32",
        "fmod2f32": 4,
        4: "fmod2f32",
        "fcmpl2f32": 5,
        5: "fcmpl2f32",
        "fcmpg2f32": 6,
        6: "fcmpg2f32",
        "ldboolean": 7,
        7: "ldboolean",
        "ldnumber": 8,
        8: "ldnumber",
        "ldstring": 9,
        9: "ldstring",
        "ldbigint": 10,
        10: "ldbigint",
        "add2Dyn": 11,
        11: "add2Dyn",
        "sub2Dyn": 12,
        12: "sub2Dyn",
        "mul2Dyn": 13,
        13: "mul2Dyn",
        "div2Dyn": 14,
        14: "div2Dyn",
        "mod2Dyn": 15,
        15: "mod2Dyn",
        "eqDyn": 16,
        16: "eqDyn",
        "noteqDyn": 17,
        17: "noteqDyn",
        "lessDyn": 18,
        18: "lessDyn",
        "lesseqDyn": 19,
        19: "lesseqDyn",
        "greaterDyn": 20,
        20: "greaterDyn",
        "greatereqDyn": 21,
        21: "greatereqDyn",
        "shl2Dyn": 22,
        22: "shl2Dyn",
        "shr2Dyn": 23,
        23: "shr2Dyn",
        "ashr2Dyn": 24,
        24: "ashr2Dyn",
        "and2Dyn": 25,
        25: "and2Dyn",
        "or2Dyn": 26,
        26: "or2Dyn",
        "xor2Dyn": 27,
        27: "xor2Dyn",
        "tonumber": 28,
        28: "tonumber",
        "negDyn": 29,
        29: "negDyn",
        "notDyn": 30,
        30: "notDyn",
        "incDyn": 31,
        31: "incDyn",
        "decDyn": 32,
        32: "decDyn",
        "expDyn": 33,
        33: "expDyn",
        "isinDyn": 34,
        34: "isinDyn",
        "instanceofDyn": 35,
        35: "instanceofDyn",
        "strictNotEqDyn": 36,
        36: "strictNotEqDyn",
        "strictEqDyn": 37,
        37: "strictEqDyn",
        "ldlexenvDyn": 38,
        38: "ldlexenvDyn",
        "resumeGenerator": 39,
        39: "resumeGenerator",
        "getResumeMode": 40,
        40: "getResumeMode",
        "createGeneratorObj": 41,
        41: "createGeneratorObj",
        "throwUndefined": 42,
        42: "throwUndefined",
        "throwConstAssignment": 43,
        43: "throwConstAssignment",
        "getTemplateObject": 44,
        44: "getTemplateObject",
        "getnextpropname": 45,
        45: "getnextpropname",
        "Call0Dyn": 46,
        46: "Call0Dyn",
        "ThrowIfNotObject": 47,
        47: "ThrowIfNotObject",
        "IterNext": 48,
        48: "IterNext",
        "CloseIterator": 49,
        49: "CloseIterator",
        "CopyModule": 50,
        50: "CopyModule",
        "SuperCallSpread": 51,
        51: "SuperCallSpread"
    },
    "builtin.tern3": {
        "ldobject": 0,
        0: "ldobject",
        "ldfunction": 1,
        1: "ldfunction",
        "delobjprop": 2,
        2: "delobjprop",
        "defineglobalvar": 3,
        3: "defineglobalvar",
        "definelocalvar": 4,
        4: "definelocalvar",
        "definefuncexpr": 5,
        5: "definefuncexpr",
        "refeqDyn": 6,
        6: "refeqDyn",
        "callruntimerange": 7,
        7: "callruntimerange",
        "newobjspreadDyn": 8,
        8: "newobjspreadDyn",
        "newlexenvDyn": 9,
        9: "newlexenvDyn",
        "createIterResultObj": 10,
        10: "createIterResultObj",
        "suspendGenerator": 11,
        11: "suspendGenerator",
        "asyncFunctionAwaitUncaught": 12,
        12: "asyncFunctionAwaitUncaught",
        "throwUndefinedIfHole": 13,
        13: "throwUndefinedIfHole",
        "Call1Dyn": 14,
        14: "Call1Dyn",
        "copydataproperties": 15,
        15: "copydataproperties",
        "starrayspread": 16,
        16: "starrayspread",
        "GetIteratorNext": 17,
        17: "GetIteratorNext",
        "setobjectwithproto": 18,
        18: "setobjectwithproto"
    },
    "builtin.quatern4": {
        "callspreadDyn": 0,
        0: "callspreadDyn",
        "asyncFunctionResolve": 1,
        1: "asyncFunctionResolve",
        "asyncFunctionReject": 2,
        2: "asyncFunctionReject",
        "Call2Dyn": 3,
        3: "Call2Dyn"
    },
    "builtin.quin5": {
        "Call3Dyn": 0,
        0: "Call3Dyn",
        "definegettersetterbyvalue": 1,
        1: "definegettersetterbyvalue"
    },
    "builtin.r2i": {
        "tryLdGlobalByValue": 0,
        0: "tryLdGlobalByValue",
        "newobjDynrange": 1,
        1: "newobjDynrange",
        "tryStGlobalByValue": 2,
        2: "tryStGlobalByValue",
        "CalliRangeDyn": 3,
        3: "CalliRangeDyn",
        "CalliThisRangeDyn": 4,
        4: "CalliThisRangeDyn",
        "SuperCall": 5,
        5: "SuperCall"
    },
    "builtin.r3i": {
        "ldObjByValue": 0,
        0: "ldObjByValue",
        "stObjByValue": 1,
        1: "stObjByValue",
        "LdObjByIndex": 2,
        2: "LdObjByIndex",
        "StObjByIndex": 3,
        3: "StObjByIndex",
        "StOwnByIndex": 4,
        4: "StOwnByIndex",
        "StOwnByValue": 5,
        5: "StOwnByValue",
        "CreateObjectWithExcludedKeys": 6,
        6: "CreateObjectWithExcludedKeys",
        "StSuperByValue": 7,
        7: "StSuperByValue",
        "LdSuperByValue": 8,
        8: "LdSuperByValue"
    },
    "builtin.r4i": {},
    "builtin.id": {
        "ImportModule": 0,
        0: "ImportModule",
        "StModuleVar": 1,
        1: "StModuleVar"
    },
    "builtin.midr": {
        "definefuncDyn": 0,
        0: "definefuncDyn",
        "defineNCFuncDyn": 1,
        1: "defineNCFuncDyn",
        "defineGeneratorFunc": 2,
        2: "defineGeneratorFunc",
        "defineAsyncFunc": 3,
        3: "defineAsyncFunc",
        "defineMethod": 4,
        4: "defineMethod"
    },
    "builtin.idi": {
        "TryLdGlobalByName": 0,
        0: "TryLdGlobalByName",
        "TryStGlobalByName": 1,
        1: "TryStGlobalByName",
        "LdGlobalVar": 2,
        2: "LdGlobalVar",
        "StGlobalVar": 3,
        3: "StGlobalVar"
    },
    "builtin.idr3i": {
        "LdObjByName": 0,
        0: "LdObjByName",
        "StObjByName": 1,
        1: "StObjByName",
        "StOwnByName": 2,
        2: "StOwnByName",
        "LdModvarByName": 3,
        3: "LdModvarByName",
        "LdSuperByName": 4,
        4: "LdSuperByName",
        "StSuperByName": 5,
        5: "StSuperByName"
    },
    "builtin.idr4i": {},
    "builtin.i2r3": {
        "LdLexVarDyn": 0,
        0: "LdLexVarDyn"
    },
    "builtin.i2r4": {
        "StLexVarDyn": 0,
        0: "StLexVarDyn"
    },
    "builtin.imm": {
        "copyrestargs": 0,
        0: "copyrestargs",
        "createobjectwithbuffer": 1,
        1: "createobjectwithbuffer",
        "createarraywithbuffer": 2,
        2: "createarraywithbuffer",
        "createobjecthavingmethod": 3,
        3: "createobjecthavingmethod",
        "ThrowIfSuperNotCorrectCall": 4,
        4: "ThrowIfSuperNotCorrectCall"
    },
    "builtin.imr2": {
        "DefineClassWithBuffer": 0,
        0: "DefineClassWithBuffer"
    },
    "builtin.idr3": {},
    "builtin.idr4": {},
    "builtin.idr6": {}
};
var BuiltinExpander = /** @class */ (function () {
    function BuiltinExpander() {
    }
    BuiltinExpander.getSubCode = function (ins) {
        for (var key in exports.builtinsCodeMap) {
            var code = exports.builtinsCodeMap[key][ins.mnemonic];
            if (code != undefined) {
                return code;
            }
        }
        return undefined;
    };
    BuiltinExpander.expand2Builtin = function (ins, operands) {
        var code = this.getSubCode(ins);
        if ((code == undefined) || (code >= 256)) {
            throw new Error("Intrinsic getSubCode subcode(" + ins.mnemonic + ") ir = " + ins.toString());
        }
        var codeImm = new ir.Imm(ir.ResultType.Int, code);
        var newNode;
        switch (ins.mnemonic) {
            case "i32tof32":
            case "i64tof32":
            case "f64tof32":
            case "monitorenter":
            case "monitorexit":
            case "ldnan":
            case "ldinfinity":
            case "ldglobalthis":
            case "ldundefined":
            case "ldnull":
            case "ldsymbol":
            case "ldglobal":
            case "ldtrue":
            case "ldfalse":
            case "throwDyn":
            case "typeofDyn":
            case "getUnmappedArgs":
            case "toboolean":
            case "getPropIterator":
            case "asyncFunctionEnter":
            case "ldHole":
            case "ReturnUndefined":
            case "createemptyobject":
            case "createemptyarray":
            case "GetIterator":
            case "ThrowThrowNotExists":
            case "ThrowPatternNonCoercible":
            case "LdHomeObject":
                newNode = new ir.BuiltinAcc(codeImm);
                break;
            case "fadd2f32":
            case "fsub2f32":
            case "fmul2f32":
            case "fdiv2f32":
            case "fmod2f32":
            case "fcmpl2f32":
            case "fcmpg2f32":
            case "ldboolean":
            case "ldnumber":
            case "ldstring":
            case "ldbigint":
            case "add2Dyn":
            case "sub2Dyn":
            case "mul2Dyn":
            case "div2Dyn":
            case "mod2Dyn":
            case "eqDyn":
            case "noteqDyn":
            case "lessDyn":
            case "lesseqDyn":
            case "greaterDyn":
            case "greatereqDyn":
            case "shl2Dyn":
            case "shr2Dyn":
            case "ashr2Dyn":
            case "and2Dyn":
            case "or2Dyn":
            case "xor2Dyn":
            case "tonumber":
            case "negDyn":
            case "notDyn":
            case "incDyn":
            case "decDyn":
            case "expDyn":
            case "isinDyn":
            case "instanceofDyn":
            case "strictNotEqDyn":
            case "strictEqDyn":
            case "ldlexenvDyn":
            case "resumeGenerator":
            case "getResumeMode":
            case "createGeneratorObj":
            case "throwUndefined":
            case "throwConstAssignment":
            case "getTemplateObject":
            case "getnextpropname":
            case "Call0Dyn":
            case "ThrowIfNotObject":
            case "IterNext":
            case "CloseIterator":
            case "CopyModule":
            case "SuperCallSpread":
                if (!(operands[0] instanceof ir.VReg)) {
                    throw new Error("0 parameters must be VReg <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinBin2(codeImm, operands[0]);
                break;
            case "ldobject":
            case "ldfunction":
            case "delobjprop":
            case "defineglobalvar":
            case "definelocalvar":
            case "definefuncexpr":
            case "refeqDyn":
            case "callruntimerange":
            case "newobjspreadDyn":
            case "newlexenvDyn":
            case "createIterResultObj":
            case "suspendGenerator":
            case "asyncFunctionAwaitUncaught":
            case "throwUndefinedIfHole":
            case "Call1Dyn":
            case "copydataproperties":
            case "starrayspread":
            case "GetIteratorNext":
            case "setobjectwithproto":
                if (!(operands[0] instanceof ir.VReg)) {
                    throw new Error("0 parameters must be VReg <" + ins.toString() + ">");
                }
                if (!(operands[1] instanceof ir.VReg)) {
                    throw new Error("1 parameters must be VReg <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinTern3(codeImm, operands[0], operands[1]);
                break;
            case "callspreadDyn":
            case "asyncFunctionResolve":
            case "asyncFunctionReject":
            case "Call2Dyn":
                if (!(operands[0] instanceof ir.VReg)) {
                    throw new Error("0 parameters must be VReg <" + ins.toString() + ">");
                }
                if (!(operands[1] instanceof ir.VReg)) {
                    throw new Error("1 parameters must be VReg <" + ins.toString() + ">");
                }
                if (!(operands[2] instanceof ir.VReg)) {
                    throw new Error("2 parameters must be VReg <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinQuatern4(codeImm, operands[0], operands[1], operands[2]);
                break;
            case "Call3Dyn":
            case "definegettersetterbyvalue":
                if (!(operands[0] instanceof ir.VReg)) {
                    throw new Error("0 parameters must be VReg <" + ins.toString() + ">");
                }
                if (!(operands[1] instanceof ir.VReg)) {
                    throw new Error("1 parameters must be VReg <" + ins.toString() + ">");
                }
                if (!(operands[2] instanceof ir.VReg)) {
                    throw new Error("2 parameters must be VReg <" + ins.toString() + ">");
                }
                if (!(operands[3] instanceof ir.VReg)) {
                    throw new Error("3 parameters must be VReg <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinQuin5(codeImm, operands[0], operands[1], operands[2], operands[3]);
                break;
            case "tryLdGlobalByValue":
            case "newobjDynrange":
            case "tryStGlobalByValue":
            case "CalliRangeDyn":
            case "CalliThisRangeDyn":
            case "SuperCall":
                if (!(operands[0] instanceof ir.Imm)) {
                    throw new Error("0 parameters must be Imm <" + ins.toString() + ">");
                }
                if (!(operands[1] instanceof ir.VReg)) {
                    throw new Error("1 parameters must be VReg <" + ins.toString() + ">");
                }
                var imm = operands[0];
                operands.shift();
                newNode = new ir.BuiltinR2i(codeImm, imm, operands);
                break;
            case "ldObjByValue":
            case "stObjByValue":
            case "LdObjByIndex":
            case "StObjByIndex":
            case "StOwnByIndex":
            case "StOwnByValue":
            case "CreateObjectWithExcludedKeys":
            case "StSuperByValue":
            case "LdSuperByValue":
                if (!(operands[0] instanceof ir.Imm)) {
                    throw new Error("0 parameters must be Imm <" + ins.toString() + ">");
                }
                if (!(operands[1] instanceof ir.VReg)) {
                    throw new Error("1 parameters must be VReg <" + ins.toString() + ">");
                }
                if (!(operands[2] instanceof ir.VReg)) {
                    throw new Error("2 parameters must be VReg <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinR3i(codeImm, operands[0], operands[1], operands[2]);
                break;
            case "ImportModule":
            case "StModuleVar":
                if (typeof (operands[0]) != 'string') {
                    throw new Error("0 parameters must be string <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinId(codeImm, operands[0]);
                break;
            case "definefuncDyn":
            case "defineNCFuncDyn":
            case "defineGeneratorFunc":
            case "defineAsyncFunc":
            case "defineMethod":
                if (typeof (operands[0]) != 'string') {
                    throw new Error("0 parameters must be string <" + ins.toString() + ">");
                }
                if (!(operands[1] instanceof ir.VReg)) {
                    throw new Error("1 parameters must be VReg <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinMidr(codeImm, operands[0], operands[1]);
                break;
            case "TryLdGlobalByName":
            case "TryStGlobalByName":
            case "LdGlobalVar":
            case "StGlobalVar":
                if (typeof (operands[0]) != 'string') {
                    throw new Error("0 parameters must be string <" + ins.toString() + ">");
                }
                if (!(operands[1] instanceof ir.Imm)) {
                    throw new Error("1 parameters must be Imm <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinIdi(codeImm, operands[0], operands[1]);
                break;
            case "LdObjByName":
            case "StObjByName":
            case "StOwnByName":
            case "LdModvarByName":
            case "LdSuperByName":
            case "StSuperByName":
                if (typeof (operands[0]) != 'string') {
                    throw new Error("0 parameters must be string <" + ins.toString() + ">");
                }
                if (!(operands[1] instanceof ir.Imm)) {
                    throw new Error("1 parameters must be Imm <" + ins.toString() + ">");
                }
                if (!(operands[2] instanceof ir.VReg)) {
                    throw new Error("2 parameters must be VReg <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinIdr3i(codeImm, operands[0], operands[1], operands[2]);
                break;
            case "LdLexVarDyn":
                if (!(operands[0] instanceof ir.Imm)) {
                    throw new Error("0 parameters must be Imm <" + ins.toString() + ">");
                }
                if (!(operands[1] instanceof ir.Imm)) {
                    throw new Error("1 parameters must be Imm <" + ins.toString() + ">");
                }
                if (!(operands[2] instanceof ir.VReg)) {
                    throw new Error("2 parameters must be VReg <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinI2r3(codeImm, operands[0], operands[1], operands[2]);
                break;
            case "StLexVarDyn":
                if (!(operands[0] instanceof ir.Imm)) {
                    throw new Error("0 parameters must be Imm <" + ins.toString() + ">");
                }
                if (!(operands[1] instanceof ir.Imm)) {
                    throw new Error("1 parameters must be Imm <" + ins.toString() + ">");
                }
                if (!(operands[2] instanceof ir.VReg)) {
                    throw new Error("2 parameters must be VReg <" + ins.toString() + ">");
                }
                if (!(operands[3] instanceof ir.VReg)) {
                    throw new Error("3 parameters must be VReg <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinI2r4(codeImm, operands[0], operands[1], operands[2], operands[3]);
                break;
            case "copyrestargs":
            case "createobjectwithbuffer":
            case "createarraywithbuffer":
            case "createobjecthavingmethod":
            case "ThrowIfSuperNotCorrectCall":
                if (!(operands[0] instanceof ir.Imm)) {
                    throw new Error("0 parameters must be Imm <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinImm(codeImm, operands[0]);
                break;
            case "DefineClassWithBuffer":
                if (typeof (operands[0]) != 'string') {
                    throw new Error("0 parameters must be string <" + ins.toString() + ">");
                }
                if (!(operands[1] instanceof ir.Imm)) {
                    throw new Error("1 parameters must be Imm <" + ins.toString() + ">");
                }
                if (!(operands[2] instanceof ir.VReg)) {
                    throw new Error("2 parameters must be VReg <" + ins.toString() + ">");
                }
                if (!(operands[3] instanceof ir.VReg)) {
                    throw new Error("3 parameters must be VReg <" + ins.toString() + ">");
                }
                newNode = new ir.BuiltinImr2(codeImm, operands[0], operands[1], operands[2], operands[3]);
                break;
            default:
                throw new Error("Intrinsic can't found subcode(" + ins.mnemonic + ") ir = " + ins.toString());
        }
        return newNode;
    };
    return BuiltinExpander;
}());
exports.BuiltinExpander = BuiltinExpander;
//# sourceMappingURL=builtinsMap.js.map